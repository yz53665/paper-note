# 数据结构
## 1. 二叉树
+ 满二叉树：所有分支节点都有左孩子和右孩子，叶子节点都在最后一层
+ 完全二叉树：叶子节点只能出现在最下层和次下层，且最下层叶子节点集中在树的左部
+ n个节点的树高度[log_2 n] + 1

## 2. 堆
+ 是一种完全二叉树
	+ 最大值堆：子节点小于父节点
	+ 最小值堆：子节点大于父节点
+ 建堆：O(n)
+ 插入节点：O(log n)，将节点插入底层最右边，再依次上浮
+ 删除节点：O(log n)，将底层最右边节点补充到删除空位，再下调至合适位置（下沉）

# 算法
## 1. 最短路径算法
### 1.1 Dijkstra算法（O(n^2)）

## 2. 十大排序算法
![[Pasted image 20240325001030.png](../attach/Pasted%20image%2020240325001030.png)
### 2.1 冒泡排序
1. 比较相邻元素，第一个比第二个大，就交换他们两个
2. 交换完成后，最后一个就是最大的
3. 跳过最后一个，重复1-2步骤，直到所有位置完成排序
时间复杂度：最好O(n)，最坏O(n^2)，平均O(n^2)
空间：O(1)
稳定性：稳定

### 2.2 选择排序
1. 将序列分为有序和无序区域，初始有序区域为空，无序区域满
2. 无序区找到最小的值，将其与第一个值交换，有序区扩展，无序区缩小
3. 不断重复，直至无序区只剩1个
时间复杂度：始终O(n^2)
空间复杂度：O(1)
稳定性：不稳定。交换时可能把原本排前面的排到后面去

### 2.3 插入排序
1. 从第二个元素开始，取出该元素，从后往前和前面的元素对比
2. 在合适的位置插入该元素
3. 重复
时间复杂度：O(n^2)
空间复杂度：O(1)
稳定性：从后往前遍历，稳定

### 2.4 快速排序
1. 设定一个分解值将数组分成左右两部分
2. 将大于分界值得集中到右边，反之左边
3. 重复上述步骤，左右独立排序
时间复杂度：搜索O(n)，划分O(log n)，最好情况每次分到中心，则O(nlog n)，最坏每次分到最大最小，O(n^2)，平均O(n log n)
空间复杂度：需要一个栈来递归，最好O(log n+1)，最坏O(n)，平均O(log n)
稳定性：双指针遍历交换，不稳定

### 2.5 希尔排序
![[Pasted image 20240325112308.png](../attach/Pasted%20image%2020240325112308.png)
1. 间隔为n的元素一组，每组内部进行插入排序
2. 缩小n（如取一半）重复1
3. 直到n=1，这时相当于插入排序
时间复杂度：大于O(n)小于O(n^2)，无法证明最差能达到O(nlogn)
空间复杂度：O(1)
稳定性：同样的元素可能分到不同组中移动，不稳定

### 2.6 归并排序
速度仅次于快速排序，但结果有序
1. 将长度n的序列均分成两个子序列
2. 对两个子序列分别归并排序
3. 用双指针迭代两个排好的子序列，按顺序合并
时间复杂度：折半分组O(log n)，遍历O(n)，合计O(n log n)
空间复杂度：需要额外存储排序结果，O(n)
稳定性：稳定

### 2.7 堆排序
1. 建堆，按照大顶堆的特性组织
2. 取出堆顶与最后一个元素交换
3. 堆顶元素下沉
4. 重复23操作，直到堆中只剩下一个元素，排序完成
时间复杂度：建堆O(n)，n-1次删除节点O(n log n)，合计O(n log n)
空间复杂度：O(1)
稳定性：不稳定

#### 2.8 计数排序
1. 找出数组中最大值和最小值，创建一个最大-最小+1的数组
2. 统计数组中元素i的个数，将数量存入数组i中
3. 数组数字累加，得到元素需要遍历次数（或直接通过数组长度获得）
4. 从小到大，将数字填入原数组中
时间复杂度：O(n+k)，元素取值范围[0,k]
空间复杂度：O(k)
稳定性：稳定

#### 2.9 桶排序
1. 设置一定数量的数组作为空桶
2. 寻访序列，将项目一个个放到对应的桶里面
3. 对不是空的桶进行排序
4. 按顺序将桶里的项目放回原序列
时间复杂度：n个数据，m个桶，每个桶k=n/m个数据。每个桶使用归并排序，时间复杂度O(k log k)，m个桶就是 O(mk log k) = O(nlogn/m)，当m接近n时，时间复杂度可以近似为O(n)
空间复杂度：O(n+m)，n为用来装元素的额外空间，m为桶的空间
稳定性：取决于桶内算法

#### 2.10 基数排序
只可用于正数，非比较型
1. 将所有数值统一为同样数位的长度，较短的前面补零
2. 从最低位开始，依次进行依次排序
3. 从最低为一直到最高位排序完成后得到一个有序序列
![[Pasted image 20240325220112.png](../attach/Pasted%20image%2020240325220112.png)

时间复杂度：共d位数，假设每位用桶排序，r个桶，则O(d\*(N+r))
空间复杂度：O(k+N)
稳定性：稳定


#### 总结
稳定的：冒泡、插入、归并、计数、基数
不稳定：选择、快速、希尔、堆、

时间复杂度O(n^2): 冒泡、插入、选择
时间复杂度O(n log n)：快速、归并、堆

空间复杂度O(1)：冒泡、插入、选择、快速、希尔、堆