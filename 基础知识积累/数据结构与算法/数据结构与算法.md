## 二分法

时间复杂度：O(logn)
空间复杂度：O(1) （原地修改）

# 哈希表
 通过哈希函数，将其它数据格式转换为不同的数值，映射到哈希表上

#### 哈希碰撞
如果存入内容大于表的范围，可能出现两个值都映射到一个位置，这一现象叫做哈希碰撞。处理方式有两种

##### 拉链法
将冲突位置的多个元素存储于链表中，需要选取适当的哈希表大小，避免数组空值浪费内存，或是链表太长查找费时。

##### 线性探测法
需要哈希表大于数据数。如果冲突，就向下找一个空位存放信息。

#### 常见三种结构
+ 数组
+ 集合
+ 映射（map）
一般语言会提供不同的方法实现，其中哈希表O(1)实现是无序的，红黑树O(log n)是有序的。

![[Pasted image 20240315232811.png](../attach/Pasted%20image%2020240315232811.png)
![[Pasted image 20240315232819.png](../attach/Pasted%20image%2020240315232819.png)

## 堆
[二叉树和堆【超详细】_堆是不是一种二叉树-CSDN博客](https://blog.csdn.net/happy_gawang/article/details/128502859)
堆是一种完全二叉树，即除了最后一层，其它层都是满节点，且最后一层节点都是左边的。
![[Pasted image 20240325183858.png](../attach/Pasted%20image%2020240325183858.png)
完全二叉树满足对于父节点n，子节点的序号一定是``2n+1,2n+2``，所以可以直接用数组来表示一个堆。
![[Pasted image 20240325184157.png](../attach/Pasted%20image%2020240325184157.png)
#### 1. 插入
一个最小堆的插入过程如下
![[Pasted image 20240325184317.png](../attach/Pasted%20image%2020240325184317.png)

#### 2. 删除
堆中删除指删除堆顶的元素，然后用最后一个过程如下：
![[Pasted image 20240325184622.png](../attach/Pasted%20image%2020240325184622.png)
#### 4. 建堆
建堆就是对每个元素进行下沉操作

## 二叉树
#### 完全二叉树性质

假设一个节点下标是n，那么两个子节点的下标分别是2n和2n+1

#### 满二叉树
第h层的节点数为2^(h-1)个
##### 如何判断完全二叉树是否是满二叉树
向左向右的高度一致就是满二叉树

### KMP匹配算法

核心思想：字符串不匹配时，利用已有信息避免从头匹配
核心是前缀表，在当前匹配失败时，找到已经匹配上的位置再匹配

前缀表定义：记录下标i之前的字符串中，有多大长度的相同前缀后缀
前缀：不含最后一个字符，以第一个字符开头的连续字串
后缀：不含第一个字符，

如aa，最长相等前后缀为1，aaa为2，aabaa也是2（aaba和abaa中的aa，也就是前缀的前面和后缀的后面重叠在一起，能有多长是相等的）
![[Pasted image 20240413232232.png](attach/Pasted%20image%2020240413232232.png)
![[Pasted image 20240413234704.png](attach/Pasted%20image%2020240413234704.png)
构建前缀表也利用了匹配的方式



